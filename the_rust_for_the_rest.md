# 導入

この資料では、プログラミング言語Rustを知らない・知ってるけど触った事はないという方に向けた簡単な紹介をしていきます。
具体的には、Rustとはどういう言語なのか、何故生まれたのか？から、Rust言語を取り巻く現状・コミュニティについて
自分のわかる範囲でざっくり紹介できたらなと思います。

# どういう言語？

Rustは2006年に生まれた比較的新しい言語です。
オープンソースで開発されており、誰でも自由に使う事ができます。
安全性とパフォーマンスを両立した中々野心的な言語です。

最新の技術や知見を積極的に取り入れ、過去の言語や技術が犯した失敗を回避しようと設計されています。
そのため、開発者にとって非常に使いやすい「プログラマーフレンドリー」な言語だと言えます。

# 誕生の背景

従来、スピードが求められるプログラムの開発にはC/Cppが用いられて来ました
C/Cppで書かれたプログラムは非常に高速で、メモリ使用量も少なくて済みます

ただ、そんなC/Cppにも欠点があります。
それは、バグを生みやすいという性質です。
メモリ安全性の節でも触れますが、C/Cppでは人間がメモリの管理をする必要があります。
小さいプログラムならばうまく管理できると思うのですが、プログラムが大きく複雑になればなるほど
適切に管理するのは難しくなります。
C/Cppが使われているソフトウェアの一つにOSやブラウザがありますが、このような巨大なプログラムにおいて
開発者自身でメモリを適切に管理すると言うのは不可能に近いです。
そんな実情に対して開発者達は当然、「C/Cppに代わる技術があればなあ」と言うふうに考えます。

こういった状況の中で、メモリの管理を文法レベルに落とし込めないか？と言う全く新しい角度から切り込んだのがRustです。

## 安全性

プログラムを書く際、コンパイルエラーが出てその解決に時間を溶かすというのは日常茶飯事だと思います。
ただ、実行する前にエラーが出るというのはある意味ありがたい事でもあります。
本来エラーになるべき処理がビルド時に検出されず実行されてしまっったら、それは悲劇以外の何者でもありません。
開発者の視点からも、静的に検出されないエラーを解決するのは静的に検出されるエラーを直すより遥かに大変です。

ただ悲しい事に、プログラミングというのはいわば地雷原の様なもので、いつもエラーやバグと隣り合わせです。
そんな地雷原を駆け抜けるプログラマを助けるために、先人達はあの手この手で工夫を施して来ました。

Rust言語は、そう言った先人達の努力に加えて、新たな取り組みもしています。
ある意味、Rust言語は、現代のプログラミング技術の到達点の一つだと思っています。

> 勿論完璧では無いですが..

じゃあ、具体的にどんな工夫がされているの？というと、大きく分けると3つです。

1. 型安全性
2. メモリ安全性
3. スレッド安全性

### 型安全性

これは、Rustに限らず多くの言語で取り入れられているものですね。
所謂、静的型付け言語と呼ばれている分類にあたります。
ベースにあるアイデアは、「プログラム内で扱っているデータの種類を解釈する段階で決定してしまおう」というものです。
静的型付けの良いところは、プログラマが、実行時のデータの状態を心配する必要がない点です。

と言ってもなんのこっちゃって感じかも知れないので簡単な例を一つとってみましょう。
整数型が必要な文脈で文字列を渡しちゃった！、という状況を考えてみます。

この時動的型付け言語では、プログラムの実行自体は可能です。
ただ、実行時にどういう振る舞いをするのか、は気をつける必要があります。

実行時エラーを吐くかも知れません、
解釈の際に良い感じに型変換をしてくれるかも知れません、
未定義の動作が引き起こされるかも知れません、
型変換自体はされたけどそれが望んだ通りの結果ではないかも知れません
...

言語仕様について完璧に把握していれば、これらの心配は些細な事かも知れませんが何にせよ、プログラマが心配すべき事は増えます。
というか、そもそも整数が欲しい場所で文字列が渡されていたらその事を教えて欲しいですよね。
これを実現するのが、「静的型付け」になります。

Rustはこの静的型付け言語に分類されます。

> Rustは型を安全のために厳密に扱います。
> こう言った言語の事を、「強い静的方付け言語」ということもあります。

ここで一点、補足しておきたい事があります。
ここまで書いてある内容を読むと、静的型付けの方が動的型付けよりも優れている、という様に読み取れます。
個人的な意見としては、まあそうなんじゃない？と思ってはいますが、あくまで個人の感想です。

> 動的型付け言語にも素晴らしい言語はたくさんあります。
> 動的言語の一つのLuaは自分もかなりよく触っていて、良い技術だなーって感じています。

この節で大事な事は、動的 vs 静的の優劣ではなく

- Rustでは型安全性を実現している
- この型安全性は、世間一般では（強い）静的型付けと呼ばれている

この2点です。

### メモリ安全性

Rustが言及される際に最もよく取り上げられるのはメモリ安全性についてです。
Rustでは所有権とライフタイムという考え方を導入する事で、メモリの解放忘れを防いでいます。

じゃあ他の言語だとどうなの？というと、大きく分けて2つあります。

1. 人間が管理する → C等のレガシーな言語に見られる方法です　最近の言語だとZigはこの方法でメモリを管理しています
  - メモリ管理のルールは特にないので、とっつき易さはありますね
  - ただこの場合人間がきちんとメモリの解放をしないと、不要なメモリを抱える事になりセキュリティ的に大きな問題を抱えています
  - また、これが、OSレベルで起こると、そもそもプログラムが作動しなくなる・コンピュータが起動出来ないなどの致命的なバグを引き起こします
  - 一方で、この「適切なメモリの管理」をするのは非常に難しいです
  - 「コードの脆弱性の約7割はC(Cpp)で書かれたコードのメモリエラーに起因する」というMicrosoftの調査は有名ですね
2. Garbage Collectorを実装する　→ PythonやJSなど、スクリプト言語によく見られる方法です
  - よくGCと省略されています
  - 要はもう使わないメモリ領域を自動で解放する仕組みのことです
  - 実行時に「このメモリ領域は使う。これは使わない」という判断をするのでパフォーマンスが犠牲になります
  - 関数型言語にもよくみられますね

これらの方法の他にも、SwiftのARC([Automatic Reference Counting](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/))
の様な管理方法も存在します。

ARCとも共通していますが、Rustの所有権/ライフタイムルールが実現しようとしているのは1番と2番の良いとこどりです。
つまり、「メモリ管理は機械にやらせたい。でもパフォーマンスは犠牲にしたくない！」という願いを実現しているのが所有権ルールな訳です。
いやいや、そんなうまい話ある？と思うかも知れませんが、そんなうまい話を実現してしまった点が、Rustが注目されている理由の一つになっています。

> 実はRustは、メモリを完璧に管理できているわけではありません。
> マルチスレッドの文脈が絡むとメモリリークする事があります。

また余談として、所有権ルールは難しいという言説をよく目にしますが、個人的には慣れの問題では？と思っています。
寧ろ、Rust初学者がつまづきやすいのは、所有権よりもライフタイムの方じゃないかなーと感じています。

### スレッド安全性

メモリ安全性によくスポットライトが当てられますが、スレッド安全性もRustで開発する際の大きな利点の一つです。
そもそもスレッド安全性って何？って話になりますが、この概念は並列処理の文脈で登場します。

コンピュータが誕生した本当の初期の段階では、プログラムは一度に一つしか実行できませんでした。
ですが、時代が進むにつれマルチタスクの概念が登場します。
ざっくりいうと「同時に複数の処理を実行しよう」というものです。
現代の計算機は非常に高機能でCPUはマルチコアなのが当たり前の時代です。
これを利用して、プログラムのパフォーマンスを底上げ出来ることが並列処理の一番大きなモチベーションだと思います。

ここで、一つのデータを複数のプロセスで共有している状況を考えてみましょう。

> この、一つのメモリ空間を複数のプロセスで共有するモデルをスレッドと言います。
> 初期のマルチタスクでは処理毎に独立したメモリ空間を持ち、互いに干渉しない様になっていました。
> ただ、これだとオーバーヘッドが大きく（要は無駄が多かった訳です）、これを解決する方法として誕生したのが「スレッド」モデルです。

この時、各プロセスが読み込んだデータが、期待している通りのデータであることは一般に保証されません。
これは平たく言うと、読み込んだデータが既に他のスレッドによって書き換えられているかも知れないからです。
この様な、望まぬスレッドによる読み書きをする処理を書いてしまったとしても、CやJavaの様なレガシーな言語では実行できてしまいます。
それもそのはず、この「望まぬ読み書き」と言うのは、ロジックエラーであり、プログラマの都合です。
実装している言語の文法に対して間違いがなければコンパイルは通るし、実行もできてしまう訳です。
こういったロジックエラーを防ぐためには、開発者自身が不要な書き込みをしていないかに注意を払う必要があります。
なので並列処理を書くのは複雑で不具合が起こりやすい、と言うのが定説になっています。

では、Rustではどのようにスレッド安全性を保証しているかというと、ここでも所有権の概念が活躍します。
あるスレッドが特定のデータにアクセスしている時、Rust言語は、そのスレッドがデータを所有しているとみなします。
なので、他のスレッドがこのデータにアクセスしようとするとエラーを起こし、コンパイル出来ない様になります。
こうすることで、開発者は望まぬアクセスに気づくことができ、ロジックの修正に注力できる訳です。
また、これらの解釈はコンパイル時に行われるので実行時のオーバーヘッドも発生しません。

これが、Rustにおける「スレッド安全性」です。

まあ、並列処理自体が本質的に複雑で難しいロジックなので、どのみち自分を鍛える必要はあるんですが..

### 安全性のまとめ

Rust言語は「安全性」に大きな焦点を置いています。
- 型安全性の実現
- メモリ安全性の実現
- スレッド安全性の実現

また、これらの安全性を実現するのに、厳密な型システムと所有権の概念が活躍しています。

# 効率性

Rustの大きな特徴の2つ目として、非常に高速でメモリ効率が良い点があります。
そもそもCppの代替を目標としていたのもあり、基本的にC/Cppと同等のパフォーマンスを発揮します。

![benchmark graph](https://benchmarksgame-team.pages.debian.net/benchmarksgame/download/fastest-elapsed.svg)

<https://benchmarksgame-team.pages.debian.net/benchmarksgame/box-plot-summary-charts.html>　より引用

ただ高速な言語の宿命として、ビルド時間は長いです。
特にRustでは所有権のチェックもビルド時に行われるので、C/C++よりも長い傾向にあります。

# コミュニティ

Rustの大きな特徴の3つ目として、コミュニティが挙げられます。
この点はあんまり取り上げられないのですが、個人的にはかなり大事だと思うので取り上げます。

Rustはまだまだ新しい言語なので、それを取り巻く環境についても発展途上です。
今後どの様に発展していくのかはわからないですが、少なくとも現時点ではとても活発に成長を続けています。

> 以下、[THE NEWSTACKより](https://thenewstack.io/rust-growing-fastest-but-javascript-reigns-supreme/)
> 
> *Rust is the fastest-growing programming language, with its developer community doubling in size over the past two years, ..*

まだまだマイナー言語なのでコミュニティの大きさはJSやPythonに遠く及ばないです。

> ここからしばらくは、かなり個人的な感想の様なものになります
> そもそも「コミュニティ」というものは、定性的な評価が大事だと思っています
> なので一定しょうがない部分はありますが..
>
> 個人的な感想と言えるものに関してはそうと分かる様な表現にしています
> 内容自体は、そういう捉え方もあるんだー程度の受け止め方で大丈夫です

## 哲学

ただ、Rust開発チームの思惑もあって、コミュニティはRust言語を使う人達にとってポジティブな環境である事、を目指している様に感じられます。
エンジニアにとって刺激的な場所になっている（し、そうである事を目指している）と思います。

> 以下、[詳解Rustプログラミング](https://www.shoeisha.co.jp/book/detail/9784798160221) 第1章　Rustとは　より
>
> *Rustコミュニティのメンバーと会話をすると、すぐに特別な意味を持つ用語に遭遇するだろう。次にあげる用語を理解すれば、Rustがこのように進化した理由も、これから解決しようとしている問題も、理解しやすくなるだろう。*
>
> - *Empowering everyone（誰にでも力を与える）―――能力や背景を問わず、すべてのプログラマの参入を歓迎する。プログラミング（とりわけ、システムプログラミング）は、恵まれた少数の人々のためにあるのではない。*
> 
> - *Blazingly fast（猛烈に速い）―――Rustは高速なプログラミング言語だ。ライバル言語の性能に匹敵する、あるいはそれを上回るプログラムを書くことができ、しかもよりたしかな安全性が保証される。*
>
> - *Fearless concurrency（怖くない並行処理）―――同時的、並列的なプログラミングは、常に難しいと考えられてきた。Rust なら、ライバル言語に蔓延する一群のエラーから解放される。*
>
> - *No Rust 2.0（Rust 2.0は来ない）―――いま書いたRustのコードは、将来のRustコンパイラでも必ずコンパイルできる。Rustは、今後何十年も依存できる信頼性の高いプログラミング言語を意図している。バージョンアップで後方互換性を失うことは決してない。だから斬新なメジャーバージョンのリリースは決して到来しないだろう。*
>
> - *Zero-cost abstractions（ゼロコストの抽象）―――Rustから得られる機能には、ランタイムコストがかからない。Rustでプログラミングするとき、速度は安全性の犠牲にはならない。*

こういった考え方は、実際にRustを使っている人たちの間で広く浸透していると思います。
Blazing Fast!やゼロコスト抽象化、といったキーワードは、Rustに触れていると頻繁に目にしますし、
*Empowering everyone to build reliable and efficient software.*
というキャッチはGithubの[Rust公式レポジトリ](https://github.com/rust-lang/rust)にも書かれていて、Rustの中枢にある思想であることが伺えます。

> ちなみに、ゼロコスト抽象化の姿勢を最初に打ち出したのはRustではなくCppです。
> Better Cとして発展していく中、Cと同じパフォーマンスでCにはない機能を提供しよう！っていう経緯があります。
> RustはC/Cppのアカン..なところを改善しようとしている言語ではありますが、取り込めるところは勿論取り込んでいます。

Rust言語のビルドツールとして、cargoというのがあります。
特殊な状況を除いてRustで開発する際はこのcargoを使って依存関係の解決やビルドをするのですが、めちゃくちゃ簡単に使えるようになっています。
またRust言語のLSPとしてrust-analyzerというものがあります。
こちらも非常に高機能で使いやすく、正直rust-analyzerの有り無しで、開発体験は大きく変わります。
数あるLSPの中でも相当完成度は高いと思います。

> macroが絡むとrust-analyzer君がバカになってしまうことがあります。
> なのでその際はLSP無しで開発するのですが、毎度毎度、rust-analyzerの偉大さを思い知らされます。

まさしくEmpowering everyoneを体現しているツール達ですね。

## 現場感

use caseの節でも触れますが、Rust言語は様々な場面で使うことができます。
Web、組み込み、AI、OS、ゲーム、CLI、blockchain..　などなど、本当にどこでも使えちゃいます。
このように、様々な分野の知見がRustコミュニティに流れ込んでいるので、新しい発想・アイデアが充満している様に感じられます。
また、パッケージの公開や利用についても統一された方法が提供されていて非常に簡単なので、様々な技術が交わり、発火して素晴らしいものが生み出されていくというサイクルが
生まれやすい環境だなと思います。

# 人気

ここまで、Rustの紹介をして来ました。
ただRustの良い点については個人的な意見の部分も多く、それってあなたの感想ですよね感は否めません。
しかし、Rustがあまねく開発者にとって利益のある言語なのではないか？というのが実は数値で表されています。
知っている人も多いと思いますが、StackOverFlowという技術系質問サイトが毎年出しているStack Over Flow Developer Surveyというレポートがあります。
これはその年の技術のトレンドや開発者の実態について調査をしたレボートです。
2024年の最新の調査結果ではRust言語が、[最も愛されている言語として選ばれています](https://survey.stackoverflow.co/2024/technology#admired-and-desired)
実は今年だけでなく、2016年から9年連続で最も開発者から愛されている言語として、Rustが選ばれています。

> Stack Over Flow Developer SurveyのRustに関する分析については[この記事](https://zenn.dev/asamin/articles/96fe984d164e4f)がよく纏まっています
>
> またすごく余談ですが、この調査において開発者から好まれる言語の傾向としては大きく3つある様に見えます。
>
> 1. 簡単でみんなが使っている
> 	- pythonなんかがまさにこれですね
> 2. 儲かる
> 	- ElixirやClojureがこのタイプですね
> 3. エンジニアファースト
> 	- 既存の技術に対して明確な問題意識があり、それを解決するという思想を持った開発者の為に作られたタイプの言語　Rust以外にもTSやZigがこれに当てはまりますね

# Pros and Cons

ここまで、Rustの特徴について紹介して来ました。
また、ここまでで言及していない良い所、悪い所というのもたくさんあります。
なので、ここで整理も含めてRustの良い点・悪い点をザーっと列挙してみます。

## 良い点

- エンジニアファースト
- 周辺ツールが充実している
- 新しい言語なので、活気がある
- 安全性に重点が置かれている
- エラーメッセージがわかりやすい
- 実行速度が速い
- メモリ使用量が少ない
- どんな分野でも使える
- マルチプラットフォーム
- Wasmのサポートが強力
- コミュニティが楽しい（ExcitingなだけではなくWonderfulな側面も強いです）
- 将来性がある
- 表現力が高い
- 柔軟なコーディングができる
- マクロが強力
	- ElixirやLispを使っている人達からすればRustのマクロは物足りないかもしれないですが、一般的なプログラミング言語からすれば十分強力です
- ドキュメントが充実している
- パッケージ（ライブラリやフレームワーク）の利用・公開が簡単
- パッケージの完成度がどれも高い

ぱっと思いつく良い点はこんな感じです。

## 悪い点

- 癖が強い
- ビルド時間が長い
- まだまだ新しいので、ライブラリやフレームワークの充実度は古くからある言語の方が強い
- 言語仕様が巨大で複雑
- そもそも案件が少ない。というか無い
- null
- null
- null
- null
- 

## Rustは難しい？

![rust learning curve](https://res.cloudinary.com/zenn/image/fetch/s--SU7AAVIu--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_1200/https://tyrchen.github.io/rust-training/images/rust_learning_curve.png)

また、Rustの欠点としてよく、「難しい」という点が挙げられています。
個人的には、癖が強い事によって難しく感じる部分が結構大きいのではと思っているのですが、
「Luaだと実行できるのに、Rustだとエラーになってそもそもコンパイルできない　なんで！！」みたいな経験は確かにあります。

ただこの難しさは、Cppのように（Cppごめん）文法がカオスな事による難しさというよりは、そもそものロジックが難しい場合が多いです。
先ほどの例で続けると、Rustの場合はLuaと違い、所有権や型システムの要求を満たす必要があります（一応unsafe Rustという抜け道も存在します）
恐らくこの部分の要請を満たすのが難しい、というのが大半のケースだと思います。
逆に言うと、Luaで簡単に書けたと言うことはその分、安全性やパフォーマンスが犠牲になっているわけです。

こう考えてみると所有権やライフタイムが難しいと言うのは、 **安全なメモリ操作、スレッド操作について根本的な理解が要求されるので難しい** と解釈できます。
裏を返せばRustの諸概念が理解できていれば、根本的な理解を得ることができるわけです。
ここまで到達すれば、新たな技術を習得するのも圧倒的に簡単になりますし、エンジニアとしての根本的な基礎体力を鍛える事にもなります。

> これは、自分の体感としても、間違いないと思います

また、先述の通りRustはドキュメントが非常に充実しており（特に公式のドキュメントの充実具合は本当にすごいです）、
公式のオンラインドキュメントを読むだけで入門ができるとまで言われています。
なので、1次情報の存在が非常に身近に感じられる。

<!--# なぜ注目されているのか-->

# 将来性

将来性は、かなりあると思います。
事実、Microsoft, Google, Amazon, Metaなど、巨大テック企業ではすでにRustを積極的に使いたいという姿勢を露わにしています。
Discord、OpenAI、npm、Dropbox、Mozillaなどなど他の有名企業・コミュニティでもRustは使われ始めています。
最近（といっても4年前..）だとLinuxカーネルの開発にRustが新たに採用されたというニュースは大きな話題になりました。

こんな感じで技術の世界の最前線では既にRustはガンガン使われているのですが、末端？の僕たちから見ると、まだまだ遠い存在です。
そもそもの案件が殆ど無いので、実務で使おうと思うとそれなりの立ち回りが求められると思います。
ただ、そんな現状も変わっていくと考えられています。

また、習得が難しいという定説を裏返すとRustを使える人材というのはそれだけで大きな価値を持っています。
当然単価は高いです。
先程紹介したStack Over Flow Developer Surveyでは、Rustエンジニアの平均年収が76,292$となっています。
歴史的な円安のせいでこれが日本だとどうなるのかというのが想像しづらいですが、単純に円に変換すると約1220万円になります。

市場でRustの案件が増えて来た時、
習得が難しくマイナーと言われていたRustに自分から好奇心を持って習得した人材、
技術の最新の動向をキャッチアップしその中でRustにも触れている人材というのはかなり魅力的に見えるのではないでしょうか。

# usecase

先ほども触れた通りあらゆる領域でRustを活用することができるので、率直にいくと

Q. Rustはどこで使われている？
A. どこでも

となってしまいます。
実際、本当に色々な領域で使われているので、*正しい回答*を追求すると「なんでも」となってしまいます。

なので、「Rustに求められがちな技術」、「Rustが使える人に求められがちな技術」をユーズケースとします。

## 1. Wasm(フロントエンド開発)

フロントエンドといえば長年JSの独壇場でしたが、Wasmの発達により近年その状況が変わりつつあります。
JSと比較してWasmは高速な点が一番大きな需要になると思います。
まだまだWasm自体が発展途上ですし、長年Webを牽引して来たという途方もない蓄積があるのでJSが簡単に廃れることはないでしょう。
ただWasmが登場したことそれ自体が、現状のJSの限界・問題点に対する不満の顕在だとおもっています(Wasmの他にはTSの登場にも近いものがありますよね）。
Wasmはさまざまな言語からコンパイルすることが出来るという理想を掲げていますが、実際にはWasmへの対応は各言語の方でする必要があります。
RustはWasmを強力にサポートしており、ツールもかなり充実しています。
現状Wasmを使う際に、使用言語として一番有力な候補がRustです。
なので、フロントエンドの文脈でRustが使われるケースでは十中八九Wasm絡みです。

## 2. バックエンド開発

安全なプログラムを書くことができる為、堅牢で信頼性が求められる用途にも向いています。
パフォーマンスと安全性を両立できるのRust特有な点ですね。
フレームワークとしてはAxumやRocketなどが有名です。

## 3. 組み込み

Cの様に低レイヤーのコントロールが可能でパフォーマンスが高いため、組み込みの世界でも使われています。
C/Cppの代替としての需要が高い印象です。

## 4. blockchain

仮想通貨を支える暗号技術には、安全性とパフォーマンスが求められます。
安全性は当然として、暗号化の処理というのが膨大なマシンパワーを必要とするため高速な言語が好まれるわけです。
Rust言語の特性がクリティカルに活きる領域ですね。
Solanaやポルカドットといった有名プラットフォームはRustで実装されています。

## 5. データ解析・AI

BurnやPolarsといった新進気鋭のフレームワークの登場や、有名MLライブラリ（tensorflowとか）のRust移植が進んでおり、
AI開発でもRustを使えないか？という動きが最近活発になっています。
ただ、この分野はPythonが既に覇権を握っています。
技術の世界では、一度でファクトスタンダードになった技術はめちゃくちゃ息が長いというジンクス？があります。
OSはC、WebはJS、AIはPythonみたいな感じです。
Rustはまさしく、これらの各領域で新たな可能性を提案しているわけですが、AIに関してはまだまだPythonの時代が続くだろうという見方が多いです（し、自分もそう思います）。
ただメインストリームでは無いにしろ、AI開発にRustを使いたいという需要は根強くあり続けるでしょう。

## 6. CLI

ripgrep, skim, zellijなどのコマンドが有名ですがコマンドラインツールの開発で今最も好まれている言語がRustだと思います。
低レイヤーの部分にアクセス可能で、CLIツールを作るライブラリ（有名どころでいくとclapやanstyle-queryなんかがよく使われている印象）も充実しているので
CLIの世界でのRustの需要は非常に高いと思います。

<!--# ecosystem-->

<!--# その他、枝葉末節-->

<!--# QuickStart-->

<!--# IMO-->

# 最後に

今、技術の世界には複雑で巨大な波が立っていると感じています。
AIの流行や、blockchain、Wasmなど、歴史的とも言えるような大きな変化が立て続けに起こっています。
また、既存の技術を現代の知見で再発明するというムーブも徐々に広まっています。
CLIツールを始めとしてOSやブラウザなど、いわゆる枯れた技術が好まれる領域でむしろ活発な印象です。
これらの新しく大きな波の震源地で、強烈に存在感を放っているのがRust言語です。
寧ろRustの存在が、これらのムーブメントを活発にしているといっても良いでしょう。

これからの時代世界をより良くするために、世界をより面白くするために何かしたい事が生まれた時、Rustを使った事があるという経験は、広大な可能性を提供してくれると確信しています。
技術の進化がもたらす未来を切り拓き、挑戦し、創造し、成長するための道具として、Rustを使ってみませんか？
