# 導入

この資料では、プログラミング言語Rustを知らない・知ってるけど触った事はないという方に向けた簡単な紹介をしていきます
具体的には、Rustとはどういう言語なのか、何故生まれたのか？から、Rust言語を取り巻く現状・コミュニティについて
自分のわかる範囲でざっくり紹介できたらなと思います

# どういう言語？

Rustは2006年に生まれた比較的新しい言語です
オープンソースで開発されており、誰でも自由に使う事ができます
安全性とパフォーマンスを両立した中々野心的な言語です

また新しい言語というのもあり、過去の言語（や技術）が犯して来た失敗を猛烈に踏まえています
なので、（個人的には）プログラマファーストというか、開発者に優しい言語になっていると思います

# 誕生の背景

従来、スピードが求められるプログラムの開発にはC/Cppが用いられて来ました
C/Cppで書かれたプログラムは非常に高速で、メモリ使用量も少なくて済みます

ただ、そんなC/Cppにも欠点があります
それは、バグを生みやすいという性質です

## 安全性

プログラムを書く際、コンパイルエラーが出てその解決に時間を溶かすというのは日常茶飯事だと思います
ただ、実行する前にエラーが出るというのはある意味ありがたい事でもあります
本来エラーになるべき処理がビルド時に検出されず実行されてしまっったら、それは悲劇以外の何者でもありません
開発者の視点からも、静的に検出されないエラーを解決するのは静的に検出されるエラーを直すより遥かに大変です

ただ悲しい事に、プログラミングというのはいわば地雷原の様なもので、いつもエラーやバグと隣り合わせです
そんな地雷原を駆け抜けるプログラマを助けるために、先人達はあの手この手で工夫を施して来ました

Rust言語は、そう言った先人達の努力に加えて、新たな取り組みもしています
ある意味、Rust言語は、現代のプログラミング技術の到達点の一つだと思っています

> 勿論完璧では無いですが..

じゃあ、具体的にどんな工夫がされているの？という点について、大きく分けると3つあります

1. 型安全性
2. メモリ安全性
3. スレッド安全性

### 型安全性

これは、Rustに限らず多くの言語で取り入れられているものですね
所謂、静的型付け言語と呼ばれている分類にあたります
ベースにあるアイデアは、「プログラム内で扱っているデータの種類を解釈する段階で決定してしまおう」というものです
静的型付けの良いところは、プログラマがデータの種類を詳細に気にする必要がない点です

と言ってもなんのこっちゃって感じかも知れないので簡単な例を一つとってみましょう
整数型が必要な文脈で文字列を渡しちゃった！、という状況を考えてみます

この時動的型付け言語では、プログラムの実行自体は可能です
ただ、実行時にどういう振る舞いをするのか、は気をつける必要があります

実行時エラーを吐くかも知れません
解釈の際に良い感じに型変換をしてくれるかも知れません、
未定義の動作が引き起こされるかも知れません
型変換自体はされたけどそれが望んだ通りの結果ではないかも知れません
...

言語仕様について完璧に把握していれば、これらの心配は些細な事かも知れませんが何にせよ、プログラマが心配すべき事は増えます
というか、そもそも整数が欲しい場所で文字列が渡されていたらその事を教えて欲しいですよね
これを実現するのが、「静的型付け」になります

Rustはこの静的型付け言語に分類されます

> Rustは型を安全のために厳密に扱います
> こう言った言語の事を、「強い静的方付け言語」ということもあります

ここで一点、補足しておきたい事があります
ここまで書いてある内容を読むと、静的型付けの方が動的型付けよりも優れている、という様に読み取れます
個人的な意見としては、まあそうなんじゃない？と思ってはいますが、あくまで個人の感想です

> 動的型付け言語にも素晴らしい言語はたくさんあります
> 動的言語の一つのLuaは自分もかなりよく触っていて、良い技術だなーって感じています

この節で大事な事は、動的 vs 静的の優劣ではなく

- Rustでは型安全性を実現している
- この型安全性は、世間一般では（強い）静的型付けと呼ばれている

この2点です

### メモリ安全性

Rustが言及される際に最もよく取り上げられるのはメモリ安全性についてです
Rustでは所有権とライフタイムという考え方を導入する事で、メモリの解放忘れを防いでいます

じゃあ他の言語だとどうなの？というと、大きく分けて2つあります

1. 人間が管理する → C等のレガシーな言語に見られる方法です　最近の言語だとZigはこの方法でメモリを管理しています
 - メモリ管理のルールは特にないので、とっつき易さはありますね
 - ただこの場合人間がきちんとメモリの解放をしないと、不要なメモリを抱える事になりセキュリティ的に大きな問題を抱えています
 - また、これが、OSレベルで起こると、そもそもプログラムが作動しなくなる・コンピュータが起動出来ないなどの致命的なバグを引き起こします
 - 一方で、この「適切なメモリの管理」をするのは非常に難しいです
 - 「コードの脆弱性の約7割はC(Cpp)で書かれたコードのメモリエラーに起因する」というMicrosoftの調査は有名ですね
2. Garbage Collectorを実装する　→ PythonやJSなど、スクリプト言語によく見られる方法です
 - よくGCと省略されています
 - 要はもう使わないメモリ領域を自動で解放する仕組みのことです
 - 実行時に「このメモリ領域は使う。これは使わない」という判断をするのでパフォーマンスが犠牲になります
 - 関数型言語にもよくみられますね

これらの方法の他にも、SwiftのARC([Automatic Reference Counting](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/))
の様な管理方法も存在します

ARCとも共通していますが、Rustの所有権/ライフタイムルールが実現しようとしているのは1番と2番の良いとこどりです
つまり、「メモリ管理は機械にやらせたい。でもパフォーマンスは犠牲にしたくない！」という願いを実現しているのが所有権ルールな訳です
いやいや、そんなうまい話ある？と思うかも知れませんが、そんなうまい話を実現してしまった点が、Rustが注目されている理由の一つになっています

> 実はRustは、メモリを完璧に管理できているわけではありません
> マルチスレッドの文脈が絡むとメモリリークする事があります

また余談として、所有権ルールは難しいという言説をよく目にしますが、個人的には慣れの問題では？と思っています
寧ろ、Rust初学者がつまづきやすいのは、所有権よりもライフタイムの方じゃないかなーと感じています

### スレッド安全性

メモリ安全性によくスポットライトが当てられますが、スレッド安全性もRustで開発する際の大きな利点の一つです
そもそもスレッド安全性って何？って話になりますが、この概念は並列処理の文脈で登場します

コンピュータが誕生した本当の初期の段階では、プログラムは一度に一つしか実行できませんでした
ですが、時代が進むにつれマルチタスクの概念が登場します
ざっくりいうと「同時に複数の処理を実行しよう」というものです
現代の計算機は非常に高機能でCPUはマルチコアなのが当たり前の時代です
これを利用して、プログラムのパフォーマンスを底上げ出来ることが並列処理の一番大きなモチベーションだと思います

ここで、一つのデータを複数のプロセスで共有している状況を考えてみましょう

> この、一つのメモリ空間を複数のプロセスで共有するモデルをスレッドと言います
> 初期のマルチタスクでは処理毎に独立したメモリ空間を持ち、互いに干渉しない様になっていました
> ただ、これだとオーバーヘッドが大きく（要は無駄が多かった訳です）、これを解決する方法として誕生したのが「スレッド」モデルです

この時、各プロセスが読み込んだデータが、期待している通りのデータであることは一般に保証されません
これは平たく言うと、読み込んだデータが既に他のスレッドによって書き換えられているかも知れないからです
この様な、望まぬスレッドによる読み書きをする処理を書いてしまったとしても、CやJavaの様なレガシーな言語では実行できてしまいます
それもそのはず、この「望まぬ読み書き」と言うのは、ロジックエラーであり、プログラマの都合です
実装している言語の文法に対して間違いがなければコンパイルは通るし、実行もできてしまう訳です
こういったロジックエラーを防ぐためには、開発者自身が不要な書き込みをしていないかに注意を払う必要があります
なので並列処理を書くのは複雑で不具合が起こりやすい、と言うのが定説になっています

では、Rustではどのようにスレッド安全性を保証しているかというと、ここでも所有権の概念が活躍します
あるスレッドが特定のデータにアクセスしている時、Rust言語は、そのスレッドがデータを所有しているとみなします
なので、他のスレッドがこのデータにアクセスしようとするとエラーを起こし、コンパイル出来ない様になります
こうすることで、開発者は望まぬアクセスに気づくことができ、ロジックの修正に注力できる訳です
また、これらの解釈はコンパイル時に行われるので実行時のオーバーヘッドも発生しません

これが、Rustにおける「スレッド安全性」です

まあ、並列処理自体が本質的に複雑で難しいロジックなので、どのみち自分を鍛える必要はあるんですが..

### まとめ

Rust言語は「安全性」に大きな焦点を置いています
- 型安全性の実現
- メモリ安全性の実現
- スレッド安全性の実現

また、これらの安全性を実現するのに、厳密な型システムと所有権の概念が活躍しています

# 効率性

Rustの大きな特徴の2つ目として、非常に高速でメモリ効率が良い点があります
そもそもCppの代替を目標としていたのもあり、基本的にC/Cppと同等のパフォーマンスを発揮します

![benchmark graph](https://benchmarksgame-team.pages.debian.net/benchmarksgame/download/fastest-elapsed.svg)

<https://benchmarksgame-team.pages.debian.net/benchmarksgame/box-plot-summary-charts.html>　より引用

ただ高速な言語の宿命として、ビルド時間は長いです
特にRustでは所有権のチェックもビルド時に行われるので、C/C++よりも長い傾向にあります

# コミュニティ

Rustの大きな特徴の3つ目として、コミュニティが挙げられます
この点はあんまり取り上げられないのですが、個人的にはかなり大事だと思うので取り上げます

Rustはまだまだ新しい言語なので、それを取り巻く環境についても発展途上です
今後どの様に発展していくのかはわからないですが、少なくとも現時点ではとても活発に成長を続けています

> 以下、[THE NEWSTACKより](https://thenewstack.io/rust-growing-fastest-but-javascript-reigns-supreme/)
> 
> *Rust is the fastest-growing programming language, with its developer community doubling in size over the past two years, ..*

まだまだマイナー言語なのでコミュニティの大きさはJSやPythonに遠く及ばないです

> ここからしばらくは、かなり個人的な感想の様なものになります
> そもそも「コミュニティ」というものは、定性的な評価が大事だと思っています
> なので一定しょうがない部分はありますが..
>
> 個人的な感想と言えるものに関してはそうと分かる様な表現にしています
> 内容自体は、そういう捉え方もあるんだー程度の受け止め方で大丈夫です

## 哲学

ただ、Rust開発チームの思惑もあって、コミュニティはRust言語を使う人達にとってポジティブな環境である事、を目指している様に感じられます
エンジニアにとって刺激的な場所になっている（し、そうである事を目指している）と思います

> 以下、[詳解Rustプログラミング](https://www.shoeisha.co.jp/book/detail/9784798160221) 第1章　Rustとは　より
>
> *Rustコミュニティのメンバーと会話をすると、すぐに特別な意味を持つ用語に遭遇するだろう。次にあげる用語を理解すれば、Rustがこのように進化した理由も、これから解決しようとしている問題も、理解しやすくなるだろう。*
>
> - *Empowering everyone（誰にでも力を与える）―――能力や背景を問わず、すべてのプログラマの参入を歓迎する。プログラミング（とりわけ、システムプログラミング）は、恵まれた少数の人々のためにあるのではない。*
> 
> - *Blazingly fast（猛烈に速い）―――Rustは高速なプログラミング言語だ。ライバル言語の性能に匹敵する、あるいはそれを上回るプログラムを書くことができ、しかもよりたしかな安全性が保証される。*
>
> - *Fearless concurrency（怖くない並行処理）―――同時的、並列的なプログラミングは、常に難しいと考えられてきた。Rust なら、ライバル言語に蔓延する一群のエラーから解放される。*
>
> - *No Rust 2.0（Rust 2.0は来ない）―――いま書いたRustのコードは、将来のRustコンパイラでも必ずコンパイルできる。Rustは、今後何十年も依存できる信頼性の高いプログラミング言語を意図している。バージョンアップで後方互換性を失うことは決してない。だから斬新なメジャーバージョンのリリースは決して到来しないだろう。*
>
> - *Zero-cost abstractions（ゼロコストの抽象）―――Rustから得られる機能には、ランタイムコストがかからない。Rustでプログラミングするとき、速度は安全性の犠牲にはならない。*

こういった考え方は、実際にRustを使っている人たちの間で広く浸透していると思います
Blazing Fast!やゼロコスト抽象化、といったキーワードは、Rustに触れていると頻繁に目にしますし、
Empowering everyone to build reliable and efficient software.
というキャッチはGithubの[Rust公式レポジトリ](https://github.com/rust-lang/rust)にも書かれていて、Rustの中枢にある思想であることが伺えます

> ちなみに、ゼロコスト抽象化の姿勢を最初に打ち出したのはRustではなくCppです
> Better Cとして発展していく中、Cと同じパフォーマンスでCにはない機能を提供しよう！っていう発想です
> RustはC/Cppのアカン..なところを改善しようとしている言語ではありますが、取り込めるところは勿論取り込んでいます

Rust言語のビルドツールとして、cargoというのがあります
特殊な状況を除いてRustで開発する際はこのcargoを使って依存関係の解決やビルドをするのですが、めちゃくちゃ簡単に使えるようになっています
またRust言語のLSPとしてrust-analyzerというものがあります
こちらも非常に高機能で使いやすく、正直rust-analyzerの有り無しで、開発体験は大きく変わります
数あるLSPの中でも相当完成度は高いと思います

> macroが絡むとrust-analyzer君がバカになってしまうことがあります
> なのでその際はLSP無しで開発するのですが、毎度毎度、rust-analyzerの偉大さを思い知らされます

まさしくEmpowering everyoneを体現しているツール達ですね

## 現場感

use caseの節でも触れますが、Rust言語は様々な場面で使うことができます
Web、組み込み、AI、OS、ゲーム、CLI、blockchain..　などなど、本当にどこでも使えちゃいます
このように、様々な分野の知見がRustコミュニティに流れ込んでいるので、新しい発想・アイデアが充満している様に感じられます
また、パッケージの公開や利用についても統一された方法が提供されていて非常に簡単なので、様々な技術が交わり、発火して素晴らしいものが生み出されていくというサイクルが
生まれやすい環境だなと思います

# 人気

ここまで、Rustの紹介をして来ました
ただRustの良い点については個人的な意見の部分も多く、それってあなたの感想ですよね感は否めません
しかし、Rustがあまねく開発者にとって利益のある言語なのではないか？というのが実は数値で表されています
知っている人も多いと思いますが、StackOverFlowという技術系質問サイトが毎年出しているStack Over Flow Developper Surveyというレポートがあります
これはその年の技術のトレンドや開発者の実態について調査をしたレボートです
2024年の最新の調査結果ではRust言語が、[最も愛されている言語として選ばれています](https://survey.stackoverflow.co/2024/technology#admired-and-desired)
実は今年だけでなく、2016年から9年連続で最も開発者から愛されている言語として、Rustが選ばれています

> すごく余談ですが、この調査において、開発者から好まれる言語の傾向としては大きく3つある様に見えます
>
> 1. 簡単
>  - pythonなんかがまさにこれですね
> 2. 儲かる
>  - ElixirやClojureがこのタイプですね
> 3. エンジニアファースト
>  - 既存の技術に対して明確な問題意識があり、それを解決するという思想を持った開発者の為に作られたタイプの言語　Rust以外にもTSやZigがこれに当てはまりますね

# Pros and Cons

ここまで、Rustの特徴について紹介して来ました
また、ここまでで言及していない良い所、悪い所というのもたくさんあります
なので、ここで整理も含めてRustの良い点・悪い点をザーっと列挙してみます

## 良い点

- エンジニアファースト
- 周辺ツールが充実している
- 新しい言語なので、活気がある
- 安全性に重点が置かれている
- エラーメッセージがわかりやすい
- 実行速度が速い
- メモリ使用量が少ない
- どんな分野でも使える
- マルチプラットフォーム
- Wasmのサポートが強力
- コミュニティが楽しい（ExcitingなだけではなくWonderfulな側面も強いです）
- 将来性がある
- 表現力が高い
- 柔軟なコーディングができる
- マクロが強力
	- ElixirやLispを使っている人達からすればRustのマクロは物足りないかもしれないですが、一般的なプログラミング言語からすれば十分強力です
- ドキュメントが充実している
- パッケージの利用・公開が簡単

ぱっと思いつく良い点はこんな感じです

## 悪い点

- 癖が強い
- ビルド時間が長い
- まだまだ新しいので、ライブラリやフレームワークの充実度は古くからある言語の方が強い
- 言語仕様が巨大で複雑
- そもそも案件が少ない。というか無い
- null
- null
- null
- null
- 

また、Rustの欠点としてよく、「難しい」という点が挙げられています
個人的には、癖が強い事によって難しく感じる部分が結構大きいのではと思っているのですが、
「Luaだと実行できるのに、Rustだとエラーになってそもそもコンパイルできない　なんで！！」みたいな経験は確かにあります

ただこの難しさは、Cppのように（Cppごめん）文法がカオスな事による難しさというよりは、そもそものロジックが難しい場合が多いです
先ほどの例で続けると、Rustの場合はLuaと違い、所有権や型システムの要求を満たす必要があります（一応unsafe Rustという抜け道も存在します）
恐らくこの部分の要請を満たすのが難しい、というのが大半のケースだと思います
逆に言うと、Luaで簡単

難しい → 根本的な理解が要求されるので、裏を返せばRustの諸概念が理解できていれば新たな技術を習得するのが圧倒的に簡単になる
→ エンジニアの根本的な基礎体力を鍛えられる

# なぜ注目されているのか

# 将来性

# usecase

# ecosystem

# その他、枝葉末節

コンパイラが親切

# QuickStart

# IMO

開発者のための言語
